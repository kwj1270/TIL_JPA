# JPA 소개    
기존 JDBC를 사용했을때 애플리케이션 **비즈니스 로직보다 SQL 과 JDBC API를 작성하는 데 더 많은 시간을 보냈다.**              
물론 코드 중복을 없애기 위해서 Ibatis나 JDBCTemplate 같은 SQLMapper 를 도입했지만 여전히 반복해서 작업을 해야 했다.            
    
또한 데이터를 테이블에 맞춰서 보내야했기 때문에            
객체 구조는 테이블 형태에 의존적이게 될 수 밖에 없었고          
설계 또한 **객체 중점이 아닌 테이블 중점으로 설계**가 될 수 밖에 없었다.             
즉, 객체지향 모델링에 대한 장점을 포기하고 데이터 중심 모델로 설계 패러다임이 바뀐 것이다.       
       
하지만 이러한 문제점을 해결하고자 만들어진것이 있었으니 바로 **ORM 프레임워크** 이다.         
ORM 프레임워크는 객체와 관계형 데이터 베이스 간의 차이를 중간에서 해결해주는 역할을 하고 있다.      
    
JPA는 자바 ORM 기술 표준이다.    
반복적인 코드를 줄이고 개발자는 개발에 조금 더 집중 할 수 있는 환경을 만들어준다.    
참고로 저자님께서 말씀하시는 말 중에 와닿는 말이 있어 남겨본다 **개발자는 SQL 매퍼가 아니다.**     

## SQL을 직접 다룰 때 발생하는 문제  
### 반복 반복 반복 
일반적인 JDBC를 이용했을 때 DAO의 처리 방법은 아래와 같다.    
     
1. SQL 작성        
2. JDBC API를 사용해서 SQL 실행      
3. 실행 결과를 알맞게 처리 (조회 기능일 경우 객체로 매핑)       

위 3가지 과정은 CRUD 에서 모두 동일한 절차이며 이는 **반복적인 작업**이다.      
이뿐만 아니라 `Connection`하고 이를 `Close` 해주는 작업까지 포함해야한다.       
물론, JDBCTemplate 에서 Connection과 Close 작업에 대한 반복을 해결해주었지만    
우리는 아직도 SQL이 반복적인 코드를 생산할 수 밖에 없다.    

**생각해볼점**
```
member 라는 객체를 DB에 저장하고자 하면     
member 필드들을 꺼내온뒤 SQL에 삽입하는 작업을 진행해야 한다.       
그리고 이러한 작업은 앞서 말한 3가지 절차를 거쳐애한다.        

하지만 대상이 DB가 아닌 Collection 의 List라고 가정을 해보자    
List<Member> list = new ArrayList(); 
list.add(member);
우리는 단순히 리스트에 추가하기만 하면 된다.    
이것이 데이터 중심이 아닌 객체지향 중심의 개발이고 우리는 이와같은 처리를 하도록 원하고 있다.   
```

### SQL에 의존적인 개발   
앞선 과정에서 우리는 SQL 을 이용한 DAO를 완성했다고 가정을 하자       
어느날 갑자기 클라이언트측에서 새로운 기능을 요구해서 테이블에 새로운 필드를 추가시켜야 하는 상황이 발생하였다.   
이럴 경우 기존에 짜여진 관련된 모든 코드를 수정해야 한다.    
       
1. DTO 수정               
2. DAO SQL 쿼리 및 statement 수정        
3. 기타 의존된, 연관된, 관련된 코드들 수정         
    
결론적으로 SQL 문을 바꾸게 됨으로써 객체의 필드를 바꾸고 이에 관한 코드도 변경해주어야 한다.      
만약 이렇게 관련된 코드가 100개, 1000개 있다면 일일이 다 바꿔줘야 하는 수고로움이 발생한다.          
      
정리하자면 객체가 연관된 코드, 객체들을 사용할 수 있을지 없을지는 전적으로 사용하는 SQL에 달려 있다.     
이런 방식의 가장 큰 문제점은 데이터 접근 계층을 사용해서 SQL을 숨겨도      
어쩔 수 없이 DAO를 열어서 어떤 SQL이 실행되는지 확인해야 한다는 점이다.       
      
그리고 이러한 SQL에 의존적인 엔티티들은 변동이 심하므로 개발자가 신뢰할 수 없으며    
물리적으로 SQL과 JDBC API를 분리했다 하더라도 논리적으로 강한 의존성을 가지고 있다는 것이다.    

애플리케이션에서 SQL을 직접 다룰 때 발생하는 문제점을 요약하자면 아래와 같다.
   
* 진정한 의미의 계층 분할이 어렵다.   
* 엔티티를 신뢰할 수 없다.   
* SQL에 의존적인 개발을 피하기 어렵다.   
     
**용어**
```
엔티티 : 비즈니스 요구사항을 모델링한 객체   
```  
   
### JPA와 문제해결 
JPA는 기존에 개발자가 직접 SQL구문을 기술하고 사용하는 것이 아닌        
JPA API를 이용함으로써 **JPA가 개발자 대신에 적절한 SQL을 생성해서 데이터베이스에 전달한다.**          
즉, 개발자는 JPA API만 사용하면 SQL 구문을 기술하지 않아도 된다는 의미이다.    
    
* 저장 기능 
    * `persist(Entity)` : 객체를 데이터베이스에 저장한다. **INSERT SQL**
* 조회 기능 
    * `find(Entity.class, id)` : 객체 하나를 데이터베이스에서 조회한다. **SELECT SQL**  
* 수정 기능 
    * JPA는 별도의 수정 메서드를 제공하지 않는다.    
    * 영속성 컨텍스트를 이용해서 조회한 데이터 엔티티의 값을 수정하면 트랜잭션을 커밋할 때 같이 수정해준다.    
* 연관된 객체 조회  
    * JPA는 객체를 필드로 가질 수 있기때문에 조회된 데이터에서 연관된 특정 객체를 추출할 수 있다.    
    
### JPA와 문제해결 
  
 
 
 








