# 영속성 관리
JPA가 제공하는 기능     
   
1. 엔티티와 테이블을 매핑하는 설계 부분 
2. 엔티티를 실제 사용하는 부분   

이번에는 매핑한 엔티티를 `EntityManager`를 통해 어떻게 사용하는지 알아볼것입니다.     
     
**EntityManager** : 엔티티를 저장하고 수정하고, 삭제하고 조회하는 등 엔티티와 관련된 모든 일을 처리합니다.     
개발자 입장에서는 엔티티를 저장하는 가상의 데이터베이스라고 생각하면 됩니다.      

# EntityMangerFactory 와 EntityManger
데이터베이스를 1개만 사용하는 애플리케이션은 일반적으로 EntityMangerFactory를 하나만 생성합니다.    

**EntityMangerFactory 생성 방법**
```java
    EntityManagerFactory emf = Persistence.createEntityManagerFactory("jpabook");
```
`Persistence.createEntityManagerFactory("jpabook");`를 호출하면   
`META-INF/persistence.xml`에 있는    
**`<persistence-unit name="jpabook"></persistence-unit>`**의 정보를 바탕으로 `EntityManagerFactory`를 만듭니다.      

**META-INF/persistence.xml**
```xml
    <persistence-unit name="jpabook">
        <properties>

            <!-- 필수 속성 -->
            <property name="javax.persistence.jdbc.driver" value="org.h2.Driver"/>
            <property name="javax.persistence.jdbc.user" value="sa"/>
            <property name="javax.persistence.jdbc.password" value=""/>
            <property name="javax.persistence.jdbc.url" value="jdbc:h2:tcp://localhost/~/test"/>
            <property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect" />

            <!-- 옵션 -->
            <property name="hibernate.show_sql" value="true" />
            <property name="hibernate.format_sql" value="true" />
            <property name="hibernate.use_sql_comments" value="true" />
            <property name="hibernate.id.new_generator_mappings" value="true" />

            <!--<property name="hibernate.hbm2ddl.auto" value="create" />-->
        </properties>
    </persistence-unit>
```   
즉, 해당 데이터베이스 관련 설정으로 만든 `EntityManagerFactory` 객체를 생성합니다.          
이제부터 필요할 때마다 엔티티 매니저 팩토리에서 엔티티 매니저를 생성하면 됩니다.          
    
```java
EntityManager em = emf.createEntityManager();
```     

**EntityManagerFactory**는 이름그대로 공장이라는 뜻으로 공장을 만드는 비용은 상당합니다.   
그렇기에 우리는 **EntityManagerFactory**를 1개만 만들어서 애플리케이션 전체에서 **공유**하도록 설계해줘야합니다.      
**EntityManagerFactory**는 여러 쓰레드가 동시에 접근해도 안전하므로(thread-safe)    
**서로 다른 스레드 간에 자원을 공유해도 됩니다.**    

반면에 `EntityManger`는 생성하는데 비용 소모가 거의 없으나   
`EntityManger`를 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유하면 안됩니다.   
   
[사진]   

`EntityManger`는 생성했다고 해서 데이터베이스 커넥션을 사용하지는 않습니다.         
`EntityManger2`와 같이 데이터베이스와 연결이 꼭 필요한 시점에만 커넥션을 획득합니다.      
즉, 트랜잭션이 시작하면 커넥션을 사용합니다.           
   
Hibernate 를 포함한 JPA 구현체들은 EntityManagerFactory를 생성할 때 커넥션풀도 만드는데 
이는 J2SE 환경에서 사용하는 방법입니다. (일반적인 자바 프로그램 개발)    
JPA를 J2EE 환경에서 사용하면 해당 컨테이너가 제공하는 데이터소스를 사용합니다. (웹 애플리케이션 개발)    
이부분에 대해서는 추후에 설명하겠습니다.      

## 영속선 컨텍스트란?   
JPA를 이해하는데 가장 중요한 용어로 **엔티티를 영구 저장하는 환경**입니다.   
`EntityManger`로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리합니다.   

```java
em.persist(member);    
```    
지금까지는 단순히 해당 코드가 데이터베이스에 저장한다고 표현을 했습니다.          
하지만 정확히 얘기한다면 **EntityManager 를 사용해 회원 엔티티를 `영속성 컨텍스트`에 저장합니다.**       
    
**영속성 컨텍스트 :** 논리적인 개념으로 EntityManager를 생성할 때 하나 만들어집니다.   
EntityManager를 통해서 영속성 컨텍스트에 접근할 수 있고 영속성 컨텍스트를 관리할 수 있습니다.   

```
하나의 엔티티 매니저가 하나의 영속성 컨텍스트에 접근하던가 
여러 엔티티 매니저가 하나의 영속성 컨텍스트에 접근하던가 합니다.   
```
   
## 엔티티의 생명주기   
**엔티티 4가지 상태**    
* 비영속 : 영속성 컨텍스트와 전혀 관계가 없는 상태   
* 영속 : 영속성 컨텍스트에 저장된 상태   
* 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태   
* 삭제 : 삭제된 상태 

### 비영속   
> 엔티티 객체를 생성했지만 아직 저장하지 않은 상태     

* `Entity entity = new Entitiy();`

### 영속
> 엔티티가 영속성 컨텍스트에 저장된 상태        
> 영속 상태 : 영속성 컨텍스트에 의해 관리되는 엔티티 상태를 의미한다.     
   
* `em.persist(entity);`


### 준영속   
> 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않으면서 바뀌는 상태     

* `em.detach(entity)`

### 삭제      
> 엔티티가 영속성 컨텍스트에서 삭제된 상태  

* `em.remove(entity)`    















