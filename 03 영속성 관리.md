# 영속성 관리
JPA가 제공하는 기능     
   
1. 엔티티와 테이블을 매핑하는 **설계 부분** 
2. 엔티티를 **실제 사용하는 부분**   

매핑한 엔티티를 `엔티티 매니저(Entity Manager)`를 통해 어떻게 사용하는것일까?
     
**엔티티 매니저(Entity Manager)** :    
엔티티를 저장하고 수정하고, 삭제하고 조회하는 등 엔티티와 관련된 모든 일을 처리합니다.              
개발자 입장에서는 엔티티를 저장하는 가상의 데이터베이스라고 생각하면 쉽습니다.        
    
```java
EntityManager em;

em.persist(entity);
em.remove(entity)
```
* 엔티티 매니저에 엔티티를 저장/삭제              
   
# 엔티티매니저 팩토리(EntityMangerFactory) 와 엔티티매니저(EntityManger)   
## 엔티티매니저 팩토리(EntityMangerFactory)   
* 데이터베이스를 1개만 사용하는 애플리케이션은 일반적으로 엔티티매니저 팩토리(EntityMangerFactory)를 하나만 생성합니다.   
   
**엔티티매니저 팩토리(EntityMangerFactory) 생성 방법**
```java
    EntityManagerFactory emf = Persistence.createEntityManagerFactory("jpabook");
```    
**META-INF/persistence.xml**
```xml
    <persistence-unit name="jpabook">
        <properties>

            <!-- 필수 속성 -->
            <property name="javax.persistence.jdbc.driver" value="org.h2.Driver"/>
            <property name="javax.persistence.jdbc.user" value="sa"/>
            <property name="javax.persistence.jdbc.password" value=""/>
            <property name="javax.persistence.jdbc.url" value="jdbc:h2:tcp://localhost/~/test"/>
            <property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect" />

            <!-- 옵션 -->
            <property name="hibernate.show_sql" value="true" />
            <property name="hibernate.format_sql" value="true" />
            <property name="hibernate.use_sql_comments" value="true" />
            <property name="hibernate.id.new_generator_mappings" value="true" />

            <!--<property name="hibernate.hbm2ddl.auto" value="create" />-->
        </properties>
    </persistence-unit>
```     
* `Persistence.createEntityManagerFactory("jpabook");`를 호출하면 `META-INF/persistence.xml`에 있는       
* `<persistence-unit name="jpabook"></persistence-unit>`의 정보를 바탕으로 `EntityManagerFactory`를 생성합니다.           
    
## 엔티티매니저(EntityManger)   
```java
EntityManagerFactory emf = Persistence.createEntityManagerFactory("jpabook");
EntityManager em = emf.createEntityManager();
```     

* `EntityManagerFactory`는 이름 그대로 공장이라는 뜻으로 공장을 만드는 비용은 상당합니다.   
* 그렇기에 우리는 `EntityManagerFactory`를 **1개만 만들어서 애플리케이션 전체에서 공유하도록 설계**해줘야합니다.      
* `EntityManagerFactory`는 여러 쓰레드가 동시에 접근해도 안전하므로(thread-safe) **서로 다른 스레드 간에 자원을 공유해도 됩니다.**    

___ 
    
* 반면에 `EntityManger`는 생성하는데 비용 소모가 거의 없으나   
* `EntityManger`를 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유하면 안됩니다.   
   
![img](https://user-images.githubusercontent.com/50267433/99519577-638eae00-29d5-11eb-8e08-f8198290c0f9.png)

* `EntityManger`는 생성했다고 해서 데이터베이스 커넥션을 사용하지는 않습니다.         
* `EntityManger2`와 같이 데이터베이스와 연결이 꼭 필요한 시점에만 커넥션을 획득합니다.      
* 즉, 트랜잭션이 시작하면 커넥션을 사용합니다.           

## 영속선 컨텍스트란?   
* **엔티티를 영구 저장하는 환경**입니다.   
* 일종의 '캐시'와 같은 역할    
* `EntityManger`로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리합니다.   

```java
em.persist(member);    
```    
* 지금까지는 단순히 해당 코드가 데이터베이스에 저장한다고 표현을 했습니다.          
* 하지만 정확히 얘기한다면 **EntityManager 를 사용해 회원 엔티티를 `영속성 컨텍스트`에 저장합니다.**          

**영속성 컨텍스트 :** 논리적인 개념으로 EntityManager를 생성할 때 하나 만들어집니다.   
EntityManager를 통해서 영속성 컨텍스트에 접근할 수 있고 영속성 컨텍스트를 관리할 수 있습니다.   

```
하나의 엔티티 매니저가 하나의 영속성 컨텍스트에 접근하던가 
여러 엔티티 매니저가 하나의 영속성 컨텍스트에 접근하던가 합니다.   
```
   
# 엔티티의 생명주기   
**엔티티 4가지 상태**    
* 비영속 : 영속성 컨텍스트와 전혀 관계가 없는 상태   
* 영속 : 영속성 컨텍스트에 저장된 상태   
* 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태   
* 삭제 : 삭제된 상태 

## 비영속   
> 엔티티 객체를 생성했지만 아직 저장하지 않은 상태     

* `Entity entity = new Entitiy();`

## 영속
> 엔티티가 영속성 컨텍스트에 저장된 상태        
> 영속 상태 : 영속성 컨텍스트에 의해 관리되는 엔티티 상태를 의미한다.     
   
* `em.persist(entity);`


## 준영속   
> 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않으면서 바뀌는 상태     

* `em.detach(entity)`

## 삭제      
> 엔티티가 영속성 컨텍스트에서 삭제된 상태  

* `em.remove(entity)`    

# 영속성 컨텍스트의 특징    
* 영속성 컨텍스트와 식별자 값    
   * 영속성 컨텍스트는 엔티티를 식별자 값으로 구분한다.   
   * 따라서 **영속 상태는 식별자 값이 반드시 있어야 한다.**   
   * 식별자가 없으면 예외가 발생한다.    
* 영속성 컨텍스트와 데이터베이스 저장  
   * 영속성 컨텍스트에 엔티티를 저장하면 언제 데이터베이스에 저장될까?   
   * 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 존재하는 엔티티를 반영  
   * 영속성 컨텍스트에 존재하는 엔티티를 반영하는 것을 **플러시(flush)**라 한다.    
* 영속성 컨텍스트가 엔티티를 관리하면 얻게되는 장점
   * 1차 캐시  
   * 동일성 보장   
   * 트랜잭션을 지원하는 쓰기 지연   
   * 변경 감지   
   * 지연 로딩  

## 엔티티 조회   
```java
Member member = new Member();
member.setId("member1");
member.setUsername("회원1");

em.persist(member);
```
![img (1)](https://user-images.githubusercontent.com/50267433/99521280-92a61f00-29d7-11eb-998b-ab09e9f14869.png)   
  
* 영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이를 **1차 캐시**라 부른다.   
   * 트렌젝션 단위의 굉장히 짧은 메모리 공간이다
* 영속 상태 엔티티는 모두 이곳에 저장된다.
   * 즉, 영속성 컨텍스트 내부에 있는 캐시에 먼저 저장된다는 것이다.   
* 1차 캐시는 Map 구조로 이루어져있으며 키는 식별자, 값은 엔티티이다.
   * 1차 캐시의 키는 데이터베이스 기본키와 매핑되어 있다.   

```java
Member member = em.find(Member.class, "member1");
```
* 첫 번째 파라미터 : 엔티티 클래스의 타입 
* 두 번째 파라미터 : 조회할 엔티티의 식별자 값 
   
`em.find()`를 호출하면 먼저 1차 캐시에서 엔티티를 찾고 없으면 데이터베이스에서 조회한다.      
      
### 1차 캐시에서 엔티티 조회     
```java
Member member = new Member();
member.setId("member1");
member.setUsername("회원1");

em.persist(member);
Member member = em.find(Member.class, "member1");
```
![1차 캐시 조회](https://user-images.githubusercontent.com/50267433/99524346-a81d4800-29db-11eb-86fa-56ab68964a2e.png)    
   
* 앞서 말했듯이 `em.find()`를 호출하면 먼저 1차 캐시에서 엔티티를 찾고 없으면 데이터베이스에서 조회한다.        

### 데이터베이스에서 조회
```java
Member member = new Member();
member.setId("member1");
member.setUsername("회원1");

em.persist(member);
Member member = em.find(Member.class, "member2"); // 여기가 2로 바뀜 
```  
![DB 조회](https://user-images.githubusercontent.com/50267433/99524098-4ceb5580-29db-11eb-9d88-03a80f194ea9.png)

* `em.find()`를 호출하면 먼저 1차 캐시에서 엔티티를 찾고 없으면 데이터베이스에서 조회한다.        
* 현재 1차 캐시에 `member2`식별자를 가진 엔티티가 존재하지 않으므로 DB를 조회한다.  
* DB에서 조회한 데이터로 `member2`식별자를 가진 엔티티를 생성해서 1차 캐시에 저장한다.(영속 상태로 만든다.)   
* 조회한 엔티티를 반환한다.    
   
1차 캐시에 만들어 놓는 이유는?       
캐시의 개념처럼 해당 엔티티를 다음에 다시 사용할 일이 있을 때 DB 연결을 하지않고 빠르게 사용하여 성능상 이점을 누릴 수 있다.         

### 영속성 엔티티 동일성 보장   
```java
Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member2");

System.out.println(a == b);
```
* `a == b` 는 참일까 거짓일까?
* 정답은 **참**이다.   
* 특정 식별자를 반복해서 호출해도 **같은 엔티티를 반환한다.**   
* 따라서 **영속성 컨텍스트는 1차 캐시를 이용한 성능상 이점과 같은 엔티티를 반환함으로써 엔티티의 동일성을 보장한다.**     

**참고**
```
동일성: 실제 인스턴스가 같다. 따라서 참조 값을 비교하는 == 비교의 값이 같다.   
동등성: 실제 인스턴스는 다를 수 있지만 인스턴스가 가지고 있는 값이 같다. equals()   
```
```
JPA는 1차 캐시를 텅해 반복 가능한 읽기(REPEATBLE READ) 등급의 트랜잭션 격리 수준을
데이터베이스가 아닌 애플리케이션 차원에서 제공한다는 장점이 있다.   
```




      

    














